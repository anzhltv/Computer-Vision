# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ujhVyVGTa0Lei7eoMvFRgm3MRqRQ0lY5
"""

from keras.datasets import mnist

(X_train, y_train), (X_test, y_test) = mnist.load_data()

X_train.shape, X_test.shape

"""MNIST представляет из себя черно-белые изображения 28 на 28 пикселей. Одновременно подгружаются на тренировку и на тест."""

X_train[0].shape
X_test[0].shape

import matplotlib.pyplot as plt

fig, ax = plt.subplots(1, 5, figsize=(15, 10))

for i in range(5):
  ax[i].imshow(X_train[i], cmap='gray')
  ax[i].axis('off')

"""axis - масштаб """

y_train[:5]

import numpy as np
idxs = np.where((y_train == 0) | (y_train == 1))
y_train = y_train[idxs]

X_train = X_train[idxs]

X_train = X_train[idxs]

idxs = np.where((y_test == 0) | (y_test == 1))
y_test = y_test[idxs]

X_test = X_test[idxs]

X_test.shape,  y_test.shape

fig, ax = plt.subplots(1, 5, figsize=(15, 10))

for i in range(5):
  ax[i].imshow(X_train[i], cmap='gray')
  ax[i].axis('off')

y_train[:5]

print(X_train.min(), X_train.max())

X_train = X_train / 255.0
X_test = X_test / 255.0

print(X_train.min(), X_train.max())

"""Так же нужно видоизменить метку класса, сейчас это лейблы 0 или 1, нужно преобразовать в бинарный вид.

Тем самым получаем 2 столбика, где первый - это метка является ли изображение 0 классом, а второй столбик - является ли изображение 1 классом.
"""

from keras.utils.np_utils import to_categorical

y_train_cat = to_categorical(y_train)
y_test_cat = to_categorical(y_test)

y_train[:5]

y_test_cat[:5]

"""бинарный вид"""

X_train[..., np.newaxis].shape

"""добавили канал для цветов (RGB)"""

import matplotlib.pyplot as plt
import tensorflow as tf

X_train_resized = tf.image.resize(X_train[..., np.newaxis], (6, 6))[..., 0]
X_test_resized = tf.image.resize(X_test[..., np.newaxis], (6, 6))[..., 0]

fig, ax = plt.subplots(1, 5, figsize=(15, 10))

for i in range(5):
    ax[i].imshow(X_train_resized[i], cmap='gray')
    ax[i].axis('off')

X_train_resized[0].numpy()

X_train_resized[0].numpy().shape

"""Преобразуем в вектор """

X_train_resized[0].numpy().flatten()

X_train_resized[0].numpy().flatten().shape

from keras.layers import Flatten
from keras.layers import Dense
from keras.models import Sequential
tf.random.set_seed(9)

model = Sequential([
    Flatten(input_shape=(6, 6)),
    Dense(2, activation='sigmoid')
])

model.summary()

"""Чтобы не растягивать картинки, вносим слой flatten. Далее полносвязнный слой на 2 нейрона
У нас задача бинарной классификации, поэтому берем функцию потерь, которая подходит сюда.

Это к примеру, бинарная кросс-энтропия.
"""

model.compile(optimizer='sgd', loss='binary_crossentropy', metrics='accuracy')

# Commented out IPython magic to ensure Python compatibility.
# %%time
# model.fit(X_train_resized, y_train_cat, epochs=5)

print("Предсказание нейронной сети: ")
pred = model.predict(X_test_resized[:1])
pred

pred_cls = pred.argmax()
pred_cls

idx = 0
plt.imshow(X_test_resized[idx])
plt.title(f'pred {pred_cls}, true {y_test[idx]}');

plt.imshow(X_test[idx])
plt.title(f'pred {pred_cls}, true {y_test[idx]}');

preds = model.predict(X_test_resized)
preds

preds_cls = preds.argmax(axis=1)
preds_cls

from sklearn.metrics import accuracy_score

print(f'test acc: {accuracy_score(y_test, preds_cls)*100:.2f}% ({(y_test == preds_cls).sum()} out of {y_test.shape[0]})')

"""Метрика качества"""